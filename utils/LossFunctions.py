import torch
import torch.nn.functional as F
from pytorch_msssim import ms_ssim

def calculate_ms_ssim_loss(output, target):
    ms_ssim_loss = 1 - ms_ssim(output, target, data_range=1.0, size_average=True)
    return ms_ssim_loss

def calculate_adversarial_loss(discriminator_output):
    # Assuming discriminator_output is the output of the discriminator for denoised_image
    # You might need to modify this based on your actual discriminator architecture and output

    # Generate labels for real (1) and fake (0) samples
    real_labels = torch.ones_like(discriminator_output)
    fake_labels = torch.zeros_like(discriminator_output)

    # Adversarial loss for real samples
    adversarial_loss_real = F.binary_cross_entropy_with_logits(discriminator_output, real_labels)

    # Generate some fake samples (you need to replace this with actual samples generated by the generator)
    fake_samples = torch.rand_like(discriminator_output)

    # Adversarial loss for fake samples
    adversarial_loss_fake = F.binary_cross_entropy_with_logits(fake_samples, fake_labels)

    # Total adversarial loss
    total_adversarial_loss = adversarial_loss_real + adversarial_loss_fake

    return total_adversarial_loss

def calculate_contrast_loss(contrast_component, target_image):
    # Assuming contrast_component and target_image are torch Tensors
    # You might need to adjust this based on your specific requirements

    # L1 loss between contrast component and target image
    contrast_loss = F.l1_loss(contrast_component, target_image)

    return contrast_loss

def calculate_detail_loss(detail_component, target_image):
    # Assuming detail_component and target_image are torch Tensors
    # You might need to adjust this based on your specific requirements

    # L1 loss between detail component and target image
    detail_loss = F.l1_loss(detail_component, target_image)

    return detail_loss
